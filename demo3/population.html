<!DOCTYPE html>
<html>
<head>
	<style>
		body,html,#holder,#overlay{
			margin:0;
			padding:0;
			width:100%;
			height:100%;
			position: absolute;
			left:0;
			top:0;
			overflow: hidden;
			user-select:none;
			font-family: Helvetica;
		}
		#holder{
			display:flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
		}
		#network{
			width: 400px;
			height: 100%;
		}
		canvas{
			width:100%;
			z-index:2;
		}
	</style>
	<title>Simulation - population</title>
	<script type="text/javascript" src="../neat.js"></script>
</head>
<body>
	<div id="holder">
		<canvas id="canvas"></canvas>
	</div>
	<div id="overlay">
		<!-- Display neural net here ? -->
		<div>
			General Info:<br/>
			Total Population: <span bind="displayedPopulation.length">0</span><br/>
			Total food: <span bind="food.length">0</span><br/>
			Zoom: <span bind="Math.round(zoomCam*100)/100">1</span><br/>
		</div>
		<div style="height:100%">
			About selected individual:<br/>
			<div id="network"></div>
		</div>
	</div>
	<script type="text/javascript">
		// "use strict";
		// Main stuff.

		const viewInputsCount = 5;

		const worldSize = 100;
		const inputCount = 2 * viewInputsCount + 1;
		const outputCount = 3 + 1;
		const foodSize = 2;

		const inputNames = [
			"viewF1","viewF2","viewF3","viewF4","viewF5", // see food
			"viewA1","viewA2","viewA3","viewA4","viewA5", // see others
			"totEnergy"
		];
		const outputNames = [
			"rotLeft","rotRight"
		];

		const maxsize = 5;

		class Individual{
			constructor(){
				this.x = worldSize * (Math.random());
				this.y = worldSize * (Math.random());
				this.rotation = Math.PI * 2 * Math.random();

				this.memoryCell = false;
				this.timer = 0;
				this.energy = 100;
				this.currentSpeed = 1;


				this.traits = { // geneticaly transmitted. (check copy)
					size: (maxsize-1) * Math.random() + 1,
					color:[Math.random() * 255,Math.random()*255,Math.random()*255],
					speed:3, // max speed
					fov:Math.PI/2, // 45 deg
				};
				this.net = new Network(inputNames,outputNames);
				boundaryPosition(this); // makes position within the edges of the world.

			}
			copy(){
				// only copy traits and brain ie the stuff that evolves.
				let i = new Individual();
				i.net = this.net.copy();
				i.traits = JSON.parse(JSON.stringify(this.traits));
				
				i.x = this.x;
				i.y = this.y;
				return i;
			}
			mutate(strength){
				// mutate traits and network
				this.traits.size = Math.max(1, this.traits.size + Math.random() - .5);
				// This gives a feeling for what individuals belong to the same species
				this.traits.color[0] = Math.max(0,Math.min(255,this.traits.color[0] + Math.random() * 20 - 10));
				this.traits.color[1] = Math.max(0,Math.min(255,this.traits.color[1] + Math.random() * 20 - 10));
				this.traits.color[2] = Math.max(0,Math.min(255,this.traits.color[2] + Math.random() * 20 - 10));

				this.net.mutate(strength);
			}
			mutateWeights(strength){
				// Does not affect color because same species.
				this.net.mutateWeights(strength);
				// Change the position of the individual (allows to distinguish individual from parents even if its not moving)
				this.x = worldSize * (Math.random());
				this.y = worldSize * (Math.random());
			}
		}
		function boundaryPosition(indiv){
			if(indiv.x <= indiv.traits.size){
				indiv.x = indiv.traits.size;
			}
			if(indiv.y <= indiv.traits.size){
				indiv.y = indiv.traits.size;
			}
			if(indiv.x >= worldSize - indiv.traits.size){
				indiv.x = worldSize - indiv.traits.size;
			}
			if(indiv.y >= worldSize - indiv.traits.size){
				indiv.y = worldSize - indiv.traits.size;
			}
		}
		const template = {
			copy: function(individual){
				return individual.copy();
			},
			new:function(){
				return new Individual();
			},
			mutate:function(individual,strength){
				individual.mutate(strength);
			},
			mutateWeights:function(individual,strength){
				individual.mutateWeights(strength);
			},
			breed:function(indiv1,indiv2){
				let i = indiv1.copy();
				i.net = indiv1.net.breed(indiv2.net);
				return i;
			}
		};
		// Function used to compute the fitness of everybody, runs the simulation basically.
		// if display !== undefined, the update will be slower and displayed on screen.
		const evaluate = {
			update : function(allIndiv,display){
				if(display !== undefined){
					fancyUpdate(allIndiv);
					return;
				}
			},
			fancyUpdate: function(allIndiv){
				displayedPopulation = allIndiv;

				setInterval(function(){
					processSimulation(allIndiv);
				},10);
			}
		};
		function fancyRender(){
			let everybody = pool.getEverybody();
			evaluate.fancyUpdate(everybody);
		}

		function getInputs(indiv,thingsToSee,debug){
			// View: take 5 fov things and find stuff inside of them, display output as 1/distance (things further are fainter)

			let inputView = new Array(viewInputsCount);


			for(let i = 0;i < thingsToSee.length;i++){
				if(thingsToSee[i] != indiv){
					let currentAngle = Math.atan2(thingsToSee[i].y - indiv.y,thingsToSee[i].x - indiv.x);
					let adjustedAngle = (currentAngle - indiv.rotation) % (Math.PI * 2);
					if(adjustedAngle < 0){
						adjustedAngle += 2*Math.PI;
					}



					let pos1 = computeCanvasPos(indiv.x,indiv.y);
					let pos2 = computeCanvasPos(indiv.x + Math.cos(currentAngle)*12,indiv.y + Math.sin(currentAngle)*12);

					// if adjustedAngle < fov, this object can be seen.

					if(Math.PI < adjustedAngle){ // make adjustedAngle as close to 0 as possible mod Math.PI*2
						adjustedAngle = adjustedAngle-Math.PI*2 ;
					}

					if(Math.abs(adjustedAngle) < indiv.traits.fov/2){
						
						let dist = Math.sqrt((thingsToSee[i].y - indiv.y) ** 2 + (thingsToSee[i].x - indiv.x) ** 2 + 1); // (dist is always > 0 because of +1)
						
						if(debug){ // display lines of sight
							g.beginPath();
							g.moveTo(pos1.x,pos1.y);
							g.lineTo(pos2.x,pos2.y);
							g.stroke();
						}

						// find in which view inputs the object is.
						let inpt = (adjustedAngle+indiv.traits.fov/2) / indiv.traits.fov * viewInputsCount;
						inpt = Math.floor(inpt); 

						if(inputView[inpt] === undefined || inputView[inpt] < 10/dist){ // display output as 1/distance (thing futher are fainter)
							inputView[inpt] = 10/dist;
							//inputIndiv[inpt] = i; // used to debug to check what are the individuals seen.
						}

					}
				}
			}

			return inputView;
		}

		function behaveIndividual(indiv,allindiv){
			// processes behaviour of a given individual control by its traits
			// First: compute inputs for the brain:
			let inputs = getInputs(indiv,food);
			
			let totalInputs = new Array(inputNames.length);
			// 5 values for food view.
			totalInputs[0] = inputs[0];
			totalInputs[1] = inputs[1];
			totalInputs[2] = inputs[2];
			totalInputs[3] = inputs[3];
			totalInputs[4] = inputs[4];
			// 5 values for individuals view
			inputs = getInputs(indiv,allindiv);
			totalInputs[5] = inputs[0];
			totalInputs[6] = inputs[1];
			totalInputs[7] = inputs[2];
			totalInputs[8] = inputs[3];
			totalInputs[9] = inputs[4];

			totalInputs[10] = indiv.energy;
			// Feed data to brain.

			let brainOutput = indiv.net.compute(totalInputs);
			
			let rotLeft = brainOutput[0];
			let rotRight = brainOutput[1];

			if(rotLeft > rotRight){
				indiv.rotation += Math.min(rotLeft,0.1);
			}else{
				indiv.rotation -= Math.min(rotRight,0.1);
			}

			//indiv.rotation += 0.01;
			indiv.x += Math.cos(indiv.rotation) * indiv.traits.speed / 100;
			indiv.y += Math.sin(indiv.rotation) * indiv.traits.speed / 100;
			// reduce energy because of movement
			indiv.energy -= .05;

			// boundry check.
			boundaryPosition(indiv);
		}

		function doPhysics(population){
			// Make individuals grab the food they are close to.
			// Remove a bit of evergy from everybody
			// Kill individuals with no energy left
			// Give score based on time survived

			for(let i = 0;i < population.length;i++){
				let minFoodDist = 9999;
				let minFoodIndex = -1;
				for(let j = 0;j < food.length;j++){
					let currentDist = (food[j].x - population[i].x) ** 2 + (food[j].y - population[i].y) ** 2; // dist squared

					if(currentDist < minFoodDist){
						minFoodDist = currentDist;
						minFoodIndex = j;
					}
				}
				//console.log(minFoodDist);
				if(minFoodDist < population[i].traits.size*2){
					// food grabed, removed from array
					console.log("Food eaten")
					food.splice(minFoodIndex,1);
					population[i].energy += 50;
				}

				if(population[i].energy < 0){ // Death.
					population[i].net.fitness = 0; // fitness based on age.
					population.splice(i,1);
					console.log("Death")
				}

			}
		}
		function calibrateFood(){
			if(food.length < 10){
				let newfood = {'x':Math.random() * 100,'y':Math.random() * 100,traits:{size:foodSize}};
				boundaryPosition(newfood);
				food.push(newfood);
			}
		}

		function processSimulation(population){
			calibrateFood();
			for(let i = 0;i < population.length;i++){
				behaveIndividual(population[i],population);
			}
			doPhysics(population);
		}


		// Simulation code
		// Pools stores the data about the individuals
		let pool = new CustomPool(template,{poolSize:5,poolCount:5});
		// Food stores the data about the environement.
		let food = [];
		let displayedPopulation = [];

		//pool.processGeneration(evaluate)
		fancyRender();

	</script>

	<script src="./render.js" type="text/javascript"></script>
</body>
</html>