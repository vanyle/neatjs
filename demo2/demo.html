<!DOCTYPE html>
<html>
<head>
	<title>NEAT - Evolving networks</title>
	<style>
		/* Dark theme */
		*{
			background-color:black;
			color:white;
		}
	</style>
	<script type="text/javascript" src="../neat.js"></script>
</head>
<body>
	<p>In this demo, We'll try to evolve a network able to compute a xor function</p>
	<p>A xor looks like this: f(x,y) = abs(x - y)
	<canvas id="canvas2"></canvas>
	<p>Current render of the best network.</p>
	<canvas id="canvas"></canvas>
	<p>Current species, sorted by fitness (species have a random name.)</p>
	<button onclick="processGen(10)">Process 10 generation (animated)</button>
	<pre id="species"></pre>
</body>
<script type="text/javascript">
	
	"use strict";

	const poolSettings = { // those are default settings, giving settings is optional.
		poolSize: 50,
		poolCount: 20, 
	};

	let pool = new NetworkPool(["x","y","cste"],["ok?"],poolSettings);

	let data = []; // generate data to teach the networks by giving them some examples.

	function predictionGoal(i,j){
		return (Math.abs(i - j) > 5) ? [1] : [0];
	}

	// make 100 data points for training.
	const learnSize = 10;
	for(let i = 0;i < learnSize;i++){
		for(let j = 0;j < learnSize;j++){
			let dataPoint = [[i,j,1],predictionGoal(i,j)];
			data.push(dataPoint);
		}
	}

	function processGen(rounds){

		function doRound(){
			pool.processGeneration(data,.9);
			let preData = "Name | Age | Score\n";
			for(let i = 0;i < pool.networkPools.length;i++){
				preData += pool.networkPools[i].name + " | " + pool.networkPools[i].age + " | " + pool.networkPools[i].successScore + "\n"
			}
			document.getElementById("species").innerHTML = preData;
			renderBestNet();
		}
		if(rounds === undefined){
			doRound();
		}else{
			const animationDelay = 100; // ms
			
			let counter = 0;
			let inter = setInterval(function(){
				doRound();
				counter ++;
				if(counter >= rounds){
					clearInterval(inter);
				}
			},animationDelay);
		}

		//let bestNet = pool.getBestNetwork();
		//console.log(bestNet.fitness);
	}

	function renderBestNet(){
		let canvas = document.getElementById("canvas");
		let g = canvas.getContext('2d');
		let network = pool.getBestNetwork();
		const resolution = 40;
		const zoom = 20;
		const colorAmplifier = 255;

		const xyTransform = function(x){
			// from 0 -> resolution to 0 -> learn_size
			return (x / resolution) * learnSize;
		}

		for(let i = 0;i < resolution;i++){
			for(let j = 0;j < resolution;j++){
				const netInput = [xyTransform(i),xyTransform(j),1];
				let colorResult = network.compute([xyTransform(i),xyTransform(j),1]);
				// console.log(netInput,"=>",colorResult[0]);
				g.fillStyle = "rgb(" + Math.floor(colorResult[0]*colorAmplifier) + "," + Math.floor(colorResult[0]*colorAmplifier) + "," + Math.floor(colorResult[0]*colorAmplifier) + ")";

				g.fillRect(i * canvas.width / resolution,j * canvas.height / resolution,canvas.width * 1.1 / resolution,canvas.height * 1.2 / resolution);
			}
		}
	}
	function renderExpectedResult(){
		let canvas = document.getElementById("canvas2");
		let g = canvas.getContext('2d');
		const resolution = 40;
		const zoom = 20;
		const colorAmplifier = 255;

		const xyTransform = function(x){
			return ((x - resolution/2) * 2/resolution) * zoom;
		}

		for(let i = 0;i < resolution;i++){
			for(let j = 0;j < resolution;j++){
				const netInput = [xyTransform(i),xyTransform(j),1];
				let colorResult = predictionGoal(xyTransform(i),xyTransform(j));
				// console.log(netInput,"=>",colorResult[0]);
				g.fillStyle = "rgb(" + Math.floor(colorResult[0]*colorAmplifier) + "," + Math.floor(colorResult[0]*colorAmplifier) + "," + Math.floor(colorResult[0]*colorAmplifier) + ")";

				g.fillRect(i * canvas.width / resolution,j * canvas.height / resolution,canvas.width * 1.1 / resolution,canvas.height * 1.2 / resolution);
			}
		}
	}

	renderExpectedResult();

	processGen(50);

</script>
</html>